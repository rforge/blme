cat("\n\nRUnit test cases for errors and warnings in blme:::parsePrior function, var.prior argument\n\n");


# this should be included from somewhere else, but that would seem to be
# rather difficult
checkWarning <- function (expr, msg = "", silent = getOption("RUnit")$silent) 
{
  tryWarn <- function (expr, silent = FALSE) {
    tryCatch(expr, warning = function(e) {
      call <- conditionCall(e)
      if (!is.null(call)) {
        if (identical(call[[1L]], quote(doTryCatch))) 
          call <- sys.call(-4L)
        dcall <- deparse(call)[1L]
        prefix <- paste("Warning in", dcall, ": ")
        LONG <- 75L
        msg <- conditionMessage(e)
        sm <- strsplit(msg, "\n")[[1L]]
        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], 
                                  type = "w")
        if (is.na(w)) 
          w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L], 
                                    type = "b")
        if (w > LONG) 
          prefix <- paste(prefix, "\n  ", sep = "")
      }
      else prefix <- "Warning : "
      msg <- paste(prefix, conditionMessage(e), "\n", sep = "")
      .Internal(seterrmessage(msg[1L]))
      if (!silent && identical(getOption("show.error.messages"), 
                               TRUE)) {
        cat(msg, file = stderr())
        .Internal(printDeferredWarnings())
      }
      invisible(structure(msg, class = "try-error"))
    })
  }

    if (missing(expr)) {
        stop("'expr' is missing")
    }
    if (is.null(silent)) {
        silent <- FALSE
        warning("'silent' has to be of type 'logical'. Was NULL. Set to FALSE.")
    }
    if (RUnit:::.existsTestLogger()) {
        .testLogger$incrementCheckNum()
    }
    if (!inherits(tryWarn(eval(expr, envir = parent.frame()), silent = silent), 
        "try-error")) {
        if (RUnit:::.existsTestLogger()) {
            .testLogger$setFailure()
        }
        stop("Warning not generated as expected\n", msg)
    }
    else {
        return(TRUE)
    }
}

# generated by:
if (FALSE) {
  set.seed(0);
  N <- 50;
  J.1 <- 5;
  J.2 <- 5;
  beta <- c(5, 2, 4);
  theta.1 <- matrix(rnorm(J.1 * 2), J.1, 2);
  theta.2 <- matrix(rnorm(J.2 * 3), J.2, 3);
  
  x.1 <- rnorm(N);
  x.2 <- rnorm(N);
  g.1 <- rmultinom(N, 1, runif(J.1));
  g.2 <- rmultinom(N, 1, runif(J.2));
  g.1 <- sapply(1:N, function(i) which(g.1[,i] == 1));
  g.2 <- sapply(1:N, function(i) which(g.2[,i] == 1));

  y <- rep(0, N);
  for (i in 1:N) {
    y[i] <- beta[1] + theta.1[g.1[i], 1] + theta.2[g.2[i], 1] +
      x.1[i] * (beta[2] + theta.1[g.1[i], 2] + theta.2[g.2[i], 2]) +
        x.2[i] * (beta[3] + theta.2[g.2[i], 3]) +
          rnorm(1);
  }
}

test.blme.parsePrior.cov.prior.exceptions <- function()
{
  x.1 <- c(0.503607972233726, 1.08576936214569, -0.69095383969683, -1.28459935387219, 0.046726172188352, -0.235706556439501, -0.542888255010254, -0.433310317456782, -0.649471646796233, 0.726750747385451, 1.1519117540872, 0.992160365445798, -0.429513109491881, 1.23830410085338, -0.279346281854269, 1.75790308981071, 0.560746090888056, -0.452783972553158, -0.832043296117832, -1.16657054708471, -1.0655905803883, -1.563782051071, 1.15653699715018, 0.83204712857239, -0.227328691424755, 0.266137361672105, -0.376702718583628, 2.44136462889459, -0.795339117255372, -0.0548774737115786, 0.250141322854153, 0.618243293566247, -0.172623502645857, -2.22390027400994, -1.26361438497058, 0.358728895971352, -0.0110454784656636, -0.940649162618608, -0.115825322156954, -0.814968708869917, 0.242263480859686, -1.4250983947325, 0.36594112304922, 0.248412648872596, 0.0652881816716207, 0.0191563916602738, 0.257338377155533, -0.649010077708898, -0.119168762418038, 0.66413569989411);

  x.2 <- c(1.10096910219409, 0.14377148075807, -0.117753598165951, -0.912068366948338, -1.43758624082998, -0.797089525071965, 1.25408310644997, 0.77214218580453, -0.21951562675344, -0.424810283377287, -0.418980099421959, 0.996986860909106, -0.275778029088027, 1.2560188173061, 0.646674390495345, 1.29931230256343, -0.873262111744435, 0.00837095999603331, -0.880871723252545, 0.59625901661066, 0.119717641289537, -0.282173877322451, 1.45598840106634, 0.229019590694692, 0.996543928544126, 0.781859184600258, -0.776776621764597, -0.615989907707918, 0.0465803028049967, -1.13038577760069, 0.576718781896486, -1.28074943178832, 1.62544730346494, -0.500696596002705, 1.67829720781629, -0.412519887482398, -0.97228683550556, 0.0253828675878054, 0.0274753367451927, -1.68018272239593, 1.05375086302862, -1.11959910457218, 0.335617209968815, 0.494795767113158, 0.138052708711737, -0.118792025778828, 0.197684262345795, -1.06869271125479, -0.80321321736474, -1.11376513631953);

  y <- c(10.2556670398245, 5.77156184409445, 5.2388963179889, -1.01048113754769, -2.40694356326161, 4.87659537730766, 11.0678751360507, 9.95236105245466, -1.21089148312542, 5.80498258814754, 0.684860586400015, 11.0298099678496, 5.71308913175892, 16.7456124781686, 7.4731450675828, 8.51093715973169, 2.82372959757841, 4.3443694315618, -2.96487863376567, 5.88586538048499, 0.976211065859574, 5.62948932886417, 13.6141669016732, 6.07894540274009, 9.57669016288729, 8.56529931086956, 2.02623726516967, 5.335419611075, 5.49337753963837, 0.357086593483832, 5.90421996841909, -0.0078591135781455, 12.5466815499627, -6.66182740887203, 11.9526738840087, 1.5017901567396, 1.15948360785528, 4.97438059345444, 5.91648438771629, 0.262312751711231, 10.5968851648003, -0.281646718883028, 7.38808913061462, 7.91783952393784, 6.24106797266484, 4.86354361177658, 5.04480479030089, 3.28778785631259, 1.36283750127861, -1.0792461964562);

  g.1 <- c(5, 2, 4, 4, 5, 5, 4, 3, 5, 5, 2, 3, 4, 5, 2, 2, 5, 1, 5, 2, 5, 1, 1, 1, 1, 1, 2, 1, 3, 5, 2, 1, 4, 5, 4, 2, 2, 2, 4, 3, 3, 3, 1, 5, 1, 4, 2, 3, 1, 2);
  g.2 <- c(3, 4, 1, 2, 4, 1, 1, 4, 3, 3, 3, 3, 1, 4, 3, 3, 2, 3, 3, 2, 4, 3, 4, 3, 3, 1, 3, 4, 3, 3, 3, 2, 3, 3, 2, 3, 3, 3, 4, 1, 4, 3, 3, 3, 4, 5, 2, 1, 3, 3);

  options(warn = -1);
  lmerFit  <-  lmer(y ~ x.1 + (1 | g.1), control = list(maxIter = 0L));
  blmerFit <- blmer(y ~ x.1 + (1 | g.1), control = list(maxIter = 0L),
                    cov.prior = NULL, fixef.prior = NULL, var.prior = NULL);
  options(warn = 0);
  
  RUnitOptions <- getOption("RUnit");
  RUnitOptions$silent <- TRUE;
  options("RUnit" = RUnitOptions);
  
  # Morally speaking, parsePrior isn't exposed to the user
  # so perhaps this first set of tests is excessive.
  checkException(blme:::parsePrior());
  checkException(blme:::parsePrior(NULL));
  checkException(blme:::parsePrior(notAValidObject));
  checkException(blme:::parsePrior(lmerFit));
  
  checkException(blme:::parsePrior(blmerFit, var.prior = numeric(0)))
  checkException(blme:::parsePrior(blmerFit, var.prior = list(numeric(0))));
  checkException(blme:::parsePrior(blmerFit, var.prior = "not a prior"));
  
  checkException(blme:::parsePrior(blmerFit, var.prior = "point(()"));
  
  checkWarning(blme:::parsePrior(blmerFit, var.prior = "point(value = 2, notAParam = 0)"));
  checkException(blme:::parsePrior(blmerFit, var.prior = "point(value = 'not a number')"));
  checkException(blme:::parsePrior(blmerFit, var.prior = "point(value = 0)"));
  checkException(blme:::parsePrior(blmerFit, var.prior = "point(value = 2, posterior.scale = 'not a scale')"));

  checkException(blme:::parsePrior(blmerFit, var.prior = "gamma"));
  checkException(blme:::parsePrior(blmerFit, var.prior = "inverse.gamma(-1)"));
  checkException(blme:::parsePrior(blmerFit, var.prior = "inverse.gamma(scale = -1)"));
  checkWarning(blme:::parsePrior(blmerFit, var.prior = "inverse.gamma(notAParam = 0)"));
  checkException(blme:::parsePrior(blmerFit, var.prior = "inverse.gamma(posterior.scale = 'not a scale')"));
  checkException(blme:::parsePrior(blmerFit, var.prior = "inverse.gamma(scale = 2, posterior.scale = 'sd')"));
}
