cat("\n\nRUnit test cases for blme::bglmer function\n\n");

# generated by:


test.blme.bglmer <- function()
{
  generateData <- FALSE;
  
  testRoot <- file.path(path.package(package="blme"), "unitTests");
  source(file.path(testRoot, "glmmData.R"), TRUE);
  source(file.path(testRoot, "checkWarning.R"), TRUE);

  glmerFit  <-  glmer(y ~ x.1 + x.2 + (1 | g), family=binomial());
  bglmerFit <- bglmer(y ~ x.1 + x.2 + (1 | g), family=binomial(),
                      cov.prior = NULL, fixef.prior = NULL);

  checkEquals(as.numeric(unlist(glmerFit@ST)), as.numeric(unlist(bglmerFit@ST)));
  checkEquals(glmerFit@ranef, bglmerFit@ranef, tolerance = 1.1e-5);
  checkEquals(glmerFit@fixef[-length(glmerFit@fixef)],    # off-by-one bug in glmer causes
              bglmerFit@fixef[-length(bglmerFit@fixef)]); # the last fixef to be wrong

  # I haven't yet hacked together ways of checking that bglmer will converge to the
  # right point, but as the priors just end up as penalities on the likelihood,
  # checking that the penalties are correct will have to be good enough for now.
  checkEquals(blme:::getPriorPenalty(bglmerFit), 0);
  
  bglmerFit <- blme:::setPrior(bglmerFit, cov.prior="gamma(2, 1, posterior.scale = 'sd')");
  priorPenalty <- -2 * dgamma(bglmerFit@ST[[1]][1], 2, 1, log=TRUE);
  checkEquals(blme:::getPriorPenalty(bglmerFit), priorPenalty);
  
  bglmerFit <- blme:::setPrior(bglmerFit, cov.prior=NULL,
                                fixef.prior="normal(sd = c(10, 2.5))");
  priorPenalty <- -2 * sum(dnorm(bglmerFit@fixef, rep(0, bglmerFit@dims[["p"]]),
                                 c(10, rep(2.5, bglmerFit@dims[["p"]] - 1)), log=TRUE));
  checkEquals(blme:::getPriorPenalty(bglmerFit), priorPenalty);

  RUnitOptions <- getOption("RUnit");
  RUnitOptions$silent <- TRUE;
  options("RUnit" = RUnitOptions);
  
  checkWarning(blme:::parsePrior(bglmerFit, fixef.prior="normal(common.scale = 'true')"));
}
